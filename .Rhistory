3
1+4
source('simple_arithmetic.R',echo=TRUE)
source('simple_arithmetic.R',echo=TRUE)
source('simple_arithmetic.R',echo=TRUE)
matrix?
?matrix
?summary
?summary(vector)
a <- 1:5
summary(a)
a <- 3:7
summary(a)
m <- matrix(c(0,1,0),3,4)
m
?seq
?as.vector
a <- matrix(1:10, ncol=5)
a
a[2,]*2
a<-a[2,]*2
a
a <- matrix(1:10, ncol=5)
a<-a[2,]*2
a
a <- matrix(1:10, ncol=5)
a <- c(a[1,],a[2,]*2)
a
a <- matrix(1:10, ncol=5)
a <- rbind(a[1,],a[2,]*2)
a
a <- c(1,2)
a
a <- c(1,2) * 1:10
lst <- list(c(1,2,3), c(2,3,4), c(0,10));
View(lst)
lst
lapply(list, mean)
lapply(lst, mean)
rep(1,5)
?rep
mapply(rep, 1:3, 3:1)
library(quantmod)
Dow_Jones_IA <- getSymbols("^DJI",auto.assign=FALSE,
from="1900-01-01")
chartSeries(Dow_Jones_IA,theme="white")
?lag
lag
lag(1,4)
lag(1:5,1)
prices <- getData()
?all
is.integer(c('aa',5,1))
is.integer(c(1,5,1))
setwd("C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5")
all(sapply(c(1,4,'a'), function(i) is.integer(i)))
all(sapply(c(1,4,5), function(i) is.integer(i)))
sapply(c(1,4,5), function(i) is.integer(i))
v1 = c(1,2,3)
sapply(v1, function(i) i == as.integer(i))
sapply(v1, function(i) is.integer(i))
v1 = as.numeric(v1)
sapply(v1, function(i) is.integer(i))
v1 = list(1,2,4,5)
sapply(v1, function(i) is.integer(i))
sapply(v1, function(i) i == as.integer(i))
library(xts)
is.xts(v1)
?nrow
v1 = list(a=2,b=1,c=3)
for(i in names(v1)) print(i)
for(i in names(v1)) print(v1$i)
for(i in names(v1)) print(v1[i])
for(i in names(v1)) print(v1[[i]])
for(i in 1:3) print(v1[[i]])
1<2<3
1<2&2<3
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('E01')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/a2_test_getTMA.R')
test_getTMA('E01')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
print(prices_20_rows)
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/a2_test_getTMA.R')
print(prices_20_rows)
View(initStore)
View(initClStore)
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
test_getTMA('normal')
getPosSignFromTMA(list(short=10,medium=20,long=30))
getPosSignFromTMA(list(short=10,medium=30,long=20))
getPosSignFromTMA(list(short=30,medium=20,long=10))
current_close <- 100.5
getPosSize(current_close)
getPosSize(current_close,constant=100.4)
params$lookbacks <- list(short=as.integer(5),
medium=as.integer(50),
long=as.integer(100))
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/a2_periods.R')
getPeriods('x1xxx')
as.integer(a)
as.integer("a")
"a" ==as.integer("a")
is.integer("a")
a<-list("q","qwe")
sapply(a, function(i) is.integer(i))
all(sapply(a, function(i) is.integer(i)))
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
a<- 1:10
a[[2]]
a[[1]]
a[[12]]
getOrders(['data[1:884]', 'short=5', 'medium=50', 'long=100'])
source('C:/Users/tommy/OneDrive/学校资料/Y3/COMP226/Assignment2/backtester_v5.5/strategies/a2_strategy_template.R')
getOrders(['data[1:884]', 'short=5', 'medium=50', 'long=100'])
getOrders <- function(store,
newRowList,
currentPos,
info,
params) {
###########################################################################
# You do not need to edit this next part of the code
###########################################################################
allzero  <-
rep(0, length(newRowList)) # used for initializing vectors
pos <- allzero
if (is.null(store))
store <- initStore(newRowList)
else
store <- updateStore(store, newRowList)
###########################################################################
###########################################################################
# This next code section is the only one you
# need to edit for getOrders
#
# The if condition is already correct:
# you should only start computing the moving
# averages when you have enough (close) prices
# for the long moving average
###########################################################################
if (store$iter > params$lookbacks$long) {
# ENTER STRATEGY LOGIC HERE
# You will need to get the current_close
# either from newRowList or from store$cl
# You will also need to get prices
# from store$cl
# With these you can use getTMA, getPosSignFromTMA
# and getPosSize to assign positions to the vector pos
for (i in 1:length(params$series)) {
if(i>params$lookbacks$long){
closePrices <- store$cl[[i]]
posSign <- getPosSignFromTMA(getTMA(as.xts(store$cl[[i]]), params$lookbacks))
currentClose <- closePrices[nrow(closePrices)]
pos[[i]] <- getPosSize(currentClose) * posSign
}
}
}
###########################################################################
###########################################################################
# You do not need to edit the rest of this function
###########################################################################
marketOrders <- -currentPos + pos
return(
list(
store = store,
marketOrders = marketOrders,
limitOrders1 = allzero,
limitPrices1 = allzero,
limitOrders2 = allzero,
limitPrices2 = allzero
)
)
}
###############################################################################
getTMA <- function(prices, lookbacks) {
# prices should be an xts with one of its columns called "Close"
# lookbacks should be list with exactly three elements:
# lookbacks$short  is an integer
# lookbacks$medium is an integer
# lookbacks$long   is an integer
# It should be the case that:
# lookbacks$short < lookbacks$medium < lookbacks$long
###########################################################################
## START OF 6 CHECKS
# For E01..E06: Replace TRUE to match the message in the call to stop()
if (!all(c("long", "short", "medium") %in% names(lookbacks)))
stop("E01: 'short', 'medium', or 'long' is missing from names(lookbacks)")
if (!all(sapply(lookbacks, function(i)
is.integer(i))))
stop("E02: At least one lookback is not an integer according to is.integer()")
if (lookbacks$short >= lookbacks$medium |
lookbacks$medium >= lookbacks$long)
stop("E03: lookbacks$short < lookbacks$medium < lookbacks$long doesn't hold")
if (!is.xts(prices))
stop("E04: prices is not an xts according to is.xts()")
if ("Close" %in% names(prices))
if (nrow(prices$Close) < lookbacks$long)
stop("E05: prices does not enough rows")
if (!"Close" %in% names(prices))
stop("E06: prices does not contain a column 'Close'")
## END OF 6 CHECKS
###########################################################################
ret <- list(short = 0,
medium = 0,
long = 0)
# You need to replace the assignment to ret so that the returned object:
#    - is a list
#    - has the right names (short, medium, long), and
#    - contains numeric and not xts objects
#    - and contains the correct moving average values, which should
#      have windows of the correct sizes that all end in the
#      same period, be the last row of prices
for (i in 1:3) {
res <- SMA(prices$Close, n = lookbacks[[i]])
ret[[i]] <- as.numeric(res)[nrow(res)]
}
return(ret)
}
getPosSignFromTMA <- function(tma_list) {
# This function takes a list of numbers tma_list with three elements
# called short, medium, and long, which correspond to the SMA values for
# a short, medium and long lookback, respectively.
# Note that if both this function and getTMA are correctly implemented
# then the following should work with correct input arguments:
# getPositionFromTMA(getTMA(prices,lookbacks))
# This function should return a single number that is:
#       -1 if the short SMA < medium SMA < long SMA
#        1 if the short SMA > medium SMA > long SMA
#        0 otherwise
if (tma_list$short < tma_list$medium &
tma_list$medium < tma_list$long)
return(-1)
else if (tma_list$short > tma_list$medium &
tma_list$medium > tma_list$long)
return(1)
else
return(0)
}
getPosSize <- function(current_close, constant = 1000) {
# This function should return (constant divided by current_close)
# rounded down to the nearest integer
return(floor(constant / current_close))
}
###############################################################################
# The functions below do NOT need to be edited
###############################################################################
initClStore  <- function(newRowList) {
clStore <- lapply(newRowList, function(x)
x$Close)
return(clStore)
}
updateClStore <- function(clStore, newRowList) {
clStore <-
mapply(function(x, y)
rbind(x, y$Close), clStore, newRowList, SIMPLIFY = FALSE)
return(clStore)
}
initStore <- function(newRowList, series) {
return(list(iter = 1, cl = initClStore(newRowList)))
}
updateStore <- function(store, newRowList) {
store$iter <- store$iter + 1
store$cl <- updateClStore(store$cl, newRowList)
return(store)
}
source("main.R")
View(backtest)
round(3.1415,2)
